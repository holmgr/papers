\documentclass[conference]{IEEEtran}
% Some Computer Society conferences also require the compsoc mode option,
% but others use the standard conference format.
%
% If IEEEtran.cls has not been installed into the LaTeX system files,
% manually specify the path to it like:
%\documentclass[conference]{IEEEtran}

\usepackage[numbers]{natbib}
\usepackage{listings}
\lstset{breaklines}
\usepackage{hyperref}

% *** CITATION PACKAGES ***
%
%\usepackage{cite}
% cite.sty was written by Donald Arseneau
% V1.6 and later of IEEEtran pre-defines the format of the cite.sty package
% \cite{} output to follow that of the IEEE. Loading the cite package will
% result in citation numbers being automatically sorted and properly
% "compressed/ranged". e.g., [1], [9], [2], [7], [5], [6] without using
% cite.sty will become [1], [2], [5]--[7], [9] using cite.sty. cite.sty's
% \cite will automatically add leading space, if needed. Use cite.sty's
% noadjust option (cite.sty V3.8 and later) if you want to turn this off
% such as if a citation ever needs to be enclosed in parenthesis.
% cite.sty is already installed on most LaTeX systems. Be sure and use
% version 5.0 (2009-03-20) and later if using hyperref.sty.
% The latest version can be obtained at:
% http://www.ctan.org/pkg/cite
% The documentation is contained in the cite.sty file itself.

% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}


\begin{document}
%
% paper title
% Titles are generally capitalized except for words such as a, an, and, as,
% at, but, by, for, in, nor, of, on, or, the, to and up, which are usually
% not capitalized unless they are the first or last word of the title.
% Linebreaks \\ can be used within to get better formatting as desired.
% Do not put math or special symbols in the title.
\title{How does the implementation of the Adapter pattern\\ affect maintainability as measured by DCS, DIT and CBO?}


% author names and affiliations
% use a multiple column layout for up to three different
% affiliations
\author{\IEEEauthorblockN{Viktor Holmgren}
\IEEEauthorblockA{
    Linköping University\\
    Linköping, Sweden\\
    Email: vikho394@student.liu.se}
}


% make the title area
\maketitle

% As a general rule, do not put math, special symbols or citations
% in the abstract
\begin{abstract}
    In this paper the implementation of the Adapter design pattern in two different languages: Rust and Java is compared with a focus on maintainability.
    More specifically this paper seeks to find how the Trait paradigm in Rust, which has no concept of classes nor inheritance, affects the implementation of a traditional object oriented design pattern.
    In this paper three major conclusions is drawn from the results.
    First, that the different implementations only differ marginally in terms of the software metrics used.
    Second, that the language constructs in Rust, specifically Traits, has some decisive advantages to the traditional object oriented model in Java.
    Third, that traditional software metrics as used here are problematic when comparing languages which differ considerably in the paradigms they support.
\end{abstract}

% no keywords

% For peer review papers, you can put extra information on the cover
% page as needed:
% \ifCLASSOPTIONpeerreview
% \begin{center} \bfseries EDICS Category: 3-BBND \end{center}
% \fi
%
% For peerreview papers, this IEEEtran command inserts a page break and
% creates the second title. It will be ignored for other modes.
\IEEEpeerreviewmaketitle


\section{Introduction}
As software systems grows, so does the need for appropriate design which allows for easy maintenance of existing code, and the flexibility to extend the code base with new features.
Over the years similar problems have been met by different people, and different solutions have been implemented to varying degrees of success.
Those solutions which have have stuck around and have been codified, are often referred to as, \emph{design patterns}.
The result of a design pattern implementaton depends on a number of different factors, not least the language features which are used for its implementation.
The most common types of design patterns seem to revolve around the Object oriented paradigm (\emph{OOP}).
Which is not surprising since the OOP paradigm sees extremely wide spread usage, many of the most popular languages around use it as their main paradigm, only differeing in the details.
One question one may ask one self is how the gain of using this patterns is impacted when implemented in a language which lacks any traditional OOP language constructs, such as inheritance and even classes?
Is it simply the case that these languages provide similar functionality only with a different facade?
Does the different language constructs result in a somewhat different structure and behavior but with the same result?
Or does the pattern as such have no real equivalent, perhaps that langauge removes the need for some patterns entirely?
This paper will examine how the implementation of the Adapter design pattern is affected by being implemented in the programming Rust compared to Java.
The focus in the comparison will be on the maintainability of the source code as measured by a number of differet software quality metrics: Design size in Classes (\emph{DCS}), Depth of Inheritence tree (\emph{DIT}) and Coupling between Objects (\emph{CBO}). As Rust is not traditionally a OOP language some interpretations will have to be done to translate them approapriatly. See \autoref{sub:software_metrics} for details.

% An example of a floating figure using the graphicx package.
% Note that \label must occur AFTER (or within) \caption.
% For figures, \caption should occur after the \includegraphics.
% Note that IEEEtran v1.7 and later has special internal code that
% is designed to preserve the operation of \label within \caption
% even when the captionsoff option is in effect. However, because
% of issues like this, it may be the safest practice to put all your
% \label just after \caption rather than within \caption{}.
%
% Reminder: the "draftcls" or "draftclsnofoot", not "draft", class
% option should be used if it is desired that the figures are to be
% displayed while in draft mode.
%
%\begin{figure}[!t]
%\centering
%\includegraphics[width=2.5in]{myfigure}
% where an .eps filename suffix will be assumed under latex,
% and a .pdf suffix will be assumed for pdflatex; or what has been declared
% via \DeclareGraphicsExtensions.
%\caption{Simulation results for the network.}
%\label{fig_sim}
%\end{figure}

% Note that the IEEE typically puts floats only at the top, even when this
% results in a large percentage of a column being occupied by floats.


% An example of a double column floating figure using two subfigures.
% (The subfig.sty package must be loaded for this to work.)
% The subfigure \label commands are set within each subfloat command,
% and the \label for the overall figure must come after \caption.
% \hfil is used as a separator to get equal spacing.
% Watch out that the combined width of all the subfigures on a
% line do not exceed the text width or a line break will occur.
%
%\begin{figure*}[!t]
%\centering
%\subfloat[Case I]{\includegraphics[width=2.5in]{box}%
%\label{fig_first_case}}
%\hfil
%\subfloat[Case II]{\includegraphics[width=2.5in]{box}%
%\label{fig_second_case}}
%\caption{Simulation results for the network.}
%\label{fig_sim}
%\end{figure*}
%
% Note that often IEEE papers with subfigures do not employ subfigure
% captions (using the optional argument to \subfloat[]), but instead will
% reference/describe all of them (a), (b), etc., within the main caption.
% Be aware that for subfig.sty to generate the (a), (b), etc., subfigure
% labels, the optional argument to \subfloat must be present. If a
% subcaption is not desired, just leave its contents blank,
% e.g., \subfloat[].


% An example of a floating table. Note that, for IEEE style tables, the
% \caption command should come BEFORE the table and, given that table
% captions serve much like titles, are usually capitalized except for words
% such as a, an, and, as, at, but, by, for, in, nor, of, on, or, the, to
% and up, which are usually not capitalized unless they are the first or
% last word of the caption. Table text will default to \footnotesize as
% the IEEE normally uses this smaller font for tables.
% The \label must come after \caption as always.
%
%\begin{table}[!t]
%% increase table row spacing, adjust to taste
%\renewcommand{\arraystretch}{1.3}
% if using array.sty, it might be a good idea to tweak the value of
% \extrarowheight as needed to properly center the text within the cells
%\caption{An Example of a Table}
%\label{table_example}
%\centering
%% Some packages, such as MDW tools, offer better commands for making tables
%% than the plain LaTeX2e tabular which is used here.
%\begin{tabular}{|c||c|}
%\hline
%One & Two\\
%\hline
%Three & Four\\
%\hline
%\end{tabular}
%\end{table}


% Note that the IEEE does not put floats in the very first column
% - or typically anywhere on the first page for that matter. Also,
% in-text middle ("here") positioning is typically not used, but it
% is allowed and encouraged for Computer Society conferences (but
% not Computer Society journals). Most IEEE journals/conferences use
% top floats exclusively.
% Note that, LaTeX2e, unlike IEEE journals/conferences, places
% footnotes above bottom floats. This can be corrected via the
% \fnbelowfloat command of the stfloats package.

\section{Background}
The the background goes here.

\subsection{Software Metrics}
\label{sub:software_metrics}

\subsection{Adapter Design Pattern}
\label{sub:adapter_design_pattern}

\subsection{Rust}
\label{sub:rust}
The Rust programming language is a relatively new language, which started back in 2006 by Gradon Hoare.
Since then the project has been primarily backed by the Mozilla Foundation~\cite{rustorg2017:faq}.
Rust is a system level programming aimed at performance critical systems.
It's main feature it boosts is that it guarantees memory safety without overhead, even over multiple threads~\cite{matsakis:2014:rustlang}.
Otherwise the language tries to solve problems where languages like C++ currently are most common.

\subsubsection{Traits}
\label{ssub:traits}
Traits is the main way to express abstractions in Rust, and on the surface they are very similar to what would be called an \emph{Interface} in most other languages.
They allow the programmer to declare methods with arguments and return values which the implementer types must implement.
There are however some key differences between Traits and Interfaces~\cite{rustblog2015:traits}:
\begin{itemize}
    \item Traits can not only require methods to be implemented, but can also provide default implementations. This allows Traits to fill a role similar to abstract classes.
    \item Traits can not only be implemented for new user level types, but also for existing types as the Trait implementation is completely separate from the type declaration.
    \item Traits can both be statically and dynamically dispatched. Static dispatch is done by the use of generics which results in zero abstraction overhead. Dynamic dispatch is done by the use of unsized references, i.e a \emph{Box}. This allows dispatch at run-time, good for when indirection is really needed.
\end{itemize}
See \autoref{fig:trait-example} for an example of Traits in Rust.

\begin{figure}[ht]
    \centering
\begin{lstlisting}[language=C++,showstringspaces=false]
trait Animal {
    // Instance method signatures; to be implemented by concrete types.
    fn noise(&self) -> &'static str;

    // Traits can provide default method definitions.
    fn what_does_it_say(&self) {
        println!("I go {}!", self.noise());
    }
}

// New struct/type
struct Sheep {}

// Implement concrete methods on Sheep type
impl Sheep {
    fn name(&self) -> &'static str {
        "Dolly"
    }
}

impl Animal for Sheep {
    // Concrete implementation of noise
    fn noise(&self) -> &'static str {
        "baaaaah!"
    }
}
\end{lstlisting}
\caption{Trait syntax in Rust}
\label{fig:trait-example}
\end{figure}

\subsubsection{Polymorphism}
\label{ssub:polymorphism}

\section{Implementation}
TODO: The implementation goes here.

\subsection{Java}
\label{sub:impl_java}

\subsection{Rust}
\label{sub:impl_rust}


\section{Results}
TODO: The results goes here.

\section{Discussion}
TODO: The discussion goes here.


\section{Conclusion}
TODO: The conclusion goes here.


% conference papers do not normally have an appendix


% use section* for acknowledgment
\section*{Acknowledgment}


%The authors would like to thank... \citeauthor{IEEEhowto:IEEEtranpage}


%\cite{IEEEhowto:IEEEtranpage}


% trigger a \newpage just before the given reference
% number - used to balance the columns on the last page
% adjust value as needed - may need to be readjusted if
% the document is modified later
%\IEEEtriggeratref{8}
% The "triggered" command can be changed if desired:
%\IEEEtriggercmd{\enlargethispage{-5in}}

% references section

% can use a bibliography generated by BibTeX as a .bbl file
% BibTeX documentation can be easily obtained at:
% http://mirror.ctan.org/biblio/bibtex/contrib/doc/
% The IEEEtran BibTeX style support page is at:
% http://www.michaelshell.org/tex/ieeetran/bibtex/
%\bibliographystyle{IEEEtran}
% argument is your BibTeX string definitions and bibliography database(s)
%\bibliography{IEEEabrv,../bib/paper}
%
% <OR> manually copy in the resultant .bbl file
% set second argument of \begin to the number of references
% (used to reserve space for the reference number labels box)
%\begin{thebibliography}{1}
%
%\bibliographystyle{./IEEEtran}
\bibliographystyle{IEEEtranN}
\bibliography{./IEEEabrv,./references}




% that's all folks
\end{document}


